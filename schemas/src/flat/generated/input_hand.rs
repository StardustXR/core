// automatically generated by the FlatBuffers compiler, do not modify


// @generated

use crate::common::*;
use core::mem;
use core::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[allow(unused_imports, dead_code)]
pub mod stardust_xr {

  use crate::common::*;
  use core::mem;
  use core::cmp::Ordering;

  extern crate flatbuffers;
  use self::flatbuffers::{EndianScalar, Follow};

// struct Finger, aligned to 4
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq)]
pub struct Finger(pub [u8; 160]);
impl Default for Finger { 
  fn default() -> Self { 
    Self([0; 160])
  }
}
impl core::fmt::Debug for Finger {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    f.debug_struct("Finger")
      .field("tip", &self.tip())
      .field("distal", &self.distal())
      .field("intermediate", &self.intermediate())
      .field("proximal", &self.proximal())
      .field("metacarpal", &self.metacarpal())
      .finish()
  }
}

impl flatbuffers::SimpleToVerifyInSlice for Finger {}
impl<'a> flatbuffers::Follow<'a> for Finger {
  type Inner = &'a Finger;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    <&'a Finger>::follow(buf, loc)
  }
}
impl<'a> flatbuffers::Follow<'a> for &'a Finger {
  type Inner = &'a Finger;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    flatbuffers::follow_cast_ref::<Finger>(buf, loc)
  }
}
impl<'b> flatbuffers::Push for Finger {
    type Output = Finger;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        let src = ::core::slice::from_raw_parts(self as *const Finger as *const u8, Self::size());
        dst.copy_from_slice(src);
    }
}

impl<'a> flatbuffers::Verifiable for Finger {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.in_buffer::<Self>(pos)
  }
}

impl<'a> Finger {
  #[allow(clippy::too_many_arguments)]
  pub fn new(
    tip: &Joint,
    distal: &Joint,
    intermediate: &Joint,
    proximal: &Joint,
    metacarpal: &Joint,
  ) -> Self {
    let mut s = Self([0; 160]);
    s.set_tip(tip);
    s.set_distal(distal);
    s.set_intermediate(intermediate);
    s.set_proximal(proximal);
    s.set_metacarpal(metacarpal);
    s
  }

  pub const fn get_fully_qualified_name() -> &'static str {
    "StardustXR.Finger"
  }

  pub fn tip(&self) -> &Joint {
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid struct in this slot
    unsafe { &*(self.0[0..].as_ptr() as *const Joint) }
  }

  #[allow(clippy::identity_op)]
  pub fn set_tip(&mut self, x: &Joint) {
    self.0[0..0 + 32].copy_from_slice(&x.0)
  }

  pub fn distal(&self) -> &Joint {
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid struct in this slot
    unsafe { &*(self.0[32..].as_ptr() as *const Joint) }
  }

  #[allow(clippy::identity_op)]
  pub fn set_distal(&mut self, x: &Joint) {
    self.0[32..32 + 32].copy_from_slice(&x.0)
  }

  pub fn intermediate(&self) -> &Joint {
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid struct in this slot
    unsafe { &*(self.0[64..].as_ptr() as *const Joint) }
  }

  #[allow(clippy::identity_op)]
  pub fn set_intermediate(&mut self, x: &Joint) {
    self.0[64..64 + 32].copy_from_slice(&x.0)
  }

  pub fn proximal(&self) -> &Joint {
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid struct in this slot
    unsafe { &*(self.0[96..].as_ptr() as *const Joint) }
  }

  #[allow(clippy::identity_op)]
  pub fn set_proximal(&mut self, x: &Joint) {
    self.0[96..96 + 32].copy_from_slice(&x.0)
  }

  pub fn metacarpal(&self) -> &Joint {
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid struct in this slot
    unsafe { &*(self.0[128..].as_ptr() as *const Joint) }
  }

  #[allow(clippy::identity_op)]
  pub fn set_metacarpal(&mut self, x: &Joint) {
    self.0[128..128 + 32].copy_from_slice(&x.0)
  }

  pub fn unpack(&self) -> FingerT {
    FingerT {
      tip: self.tip().unpack(),
      distal: self.distal().unpack(),
      intermediate: self.intermediate().unpack(),
      proximal: self.proximal().unpack(),
      metacarpal: self.metacarpal().unpack(),
    }
  }
}

#[derive(Debug, Clone, PartialEq, Default)]
pub struct FingerT {
  pub tip: JointT,
  pub distal: JointT,
  pub intermediate: JointT,
  pub proximal: JointT,
  pub metacarpal: JointT,
}
impl FingerT {
  pub fn pack(&self) -> Finger {
    Finger::new(
      &self.tip.pack(),
      &self.distal.pack(),
      &self.intermediate.pack(),
      &self.proximal.pack(),
      &self.metacarpal.pack(),
    )
  }
}

// struct Thumb, aligned to 4
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq)]
pub struct Thumb(pub [u8; 128]);
impl Default for Thumb { 
  fn default() -> Self { 
    Self([0; 128])
  }
}
impl core::fmt::Debug for Thumb {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    f.debug_struct("Thumb")
      .field("tip", &self.tip())
      .field("distal", &self.distal())
      .field("proximal", &self.proximal())
      .field("metacarpal", &self.metacarpal())
      .finish()
  }
}

impl flatbuffers::SimpleToVerifyInSlice for Thumb {}
impl<'a> flatbuffers::Follow<'a> for Thumb {
  type Inner = &'a Thumb;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    <&'a Thumb>::follow(buf, loc)
  }
}
impl<'a> flatbuffers::Follow<'a> for &'a Thumb {
  type Inner = &'a Thumb;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    flatbuffers::follow_cast_ref::<Thumb>(buf, loc)
  }
}
impl<'b> flatbuffers::Push for Thumb {
    type Output = Thumb;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        let src = ::core::slice::from_raw_parts(self as *const Thumb as *const u8, Self::size());
        dst.copy_from_slice(src);
    }
}

impl<'a> flatbuffers::Verifiable for Thumb {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.in_buffer::<Self>(pos)
  }
}

impl<'a> Thumb {
  #[allow(clippy::too_many_arguments)]
  pub fn new(
    tip: &Joint,
    distal: &Joint,
    proximal: &Joint,
    metacarpal: &Joint,
  ) -> Self {
    let mut s = Self([0; 128]);
    s.set_tip(tip);
    s.set_distal(distal);
    s.set_proximal(proximal);
    s.set_metacarpal(metacarpal);
    s
  }

  pub const fn get_fully_qualified_name() -> &'static str {
    "StardustXR.Thumb"
  }

  pub fn tip(&self) -> &Joint {
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid struct in this slot
    unsafe { &*(self.0[0..].as_ptr() as *const Joint) }
  }

  #[allow(clippy::identity_op)]
  pub fn set_tip(&mut self, x: &Joint) {
    self.0[0..0 + 32].copy_from_slice(&x.0)
  }

  pub fn distal(&self) -> &Joint {
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid struct in this slot
    unsafe { &*(self.0[32..].as_ptr() as *const Joint) }
  }

  #[allow(clippy::identity_op)]
  pub fn set_distal(&mut self, x: &Joint) {
    self.0[32..32 + 32].copy_from_slice(&x.0)
  }

  pub fn proximal(&self) -> &Joint {
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid struct in this slot
    unsafe { &*(self.0[64..].as_ptr() as *const Joint) }
  }

  #[allow(clippy::identity_op)]
  pub fn set_proximal(&mut self, x: &Joint) {
    self.0[64..64 + 32].copy_from_slice(&x.0)
  }

  pub fn metacarpal(&self) -> &Joint {
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid struct in this slot
    unsafe { &*(self.0[96..].as_ptr() as *const Joint) }
  }

  #[allow(clippy::identity_op)]
  pub fn set_metacarpal(&mut self, x: &Joint) {
    self.0[96..96 + 32].copy_from_slice(&x.0)
  }

  pub fn unpack(&self) -> ThumbT {
    ThumbT {
      tip: self.tip().unpack(),
      distal: self.distal().unpack(),
      proximal: self.proximal().unpack(),
      metacarpal: self.metacarpal().unpack(),
    }
  }
}

#[derive(Debug, Clone, PartialEq, Default)]
pub struct ThumbT {
  pub tip: JointT,
  pub distal: JointT,
  pub proximal: JointT,
  pub metacarpal: JointT,
}
impl ThumbT {
  pub fn pack(&self) -> Thumb {
    Thumb::new(
      &self.tip.pack(),
      &self.distal.pack(),
      &self.proximal.pack(),
      &self.metacarpal.pack(),
    )
  }
}

pub enum HandOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Hand<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Hand<'a> {
  type Inner = Hand<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Hand<'a> {
  pub const VT_RIGHT: flatbuffers::VOffsetT = 4;
  pub const VT_THUMB: flatbuffers::VOffsetT = 6;
  pub const VT_INDEX: flatbuffers::VOffsetT = 8;
  pub const VT_MIDDLE: flatbuffers::VOffsetT = 10;
  pub const VT_RING: flatbuffers::VOffsetT = 12;
  pub const VT_LITTLE: flatbuffers::VOffsetT = 14;
  pub const VT_PALM: flatbuffers::VOffsetT = 16;
  pub const VT_WRIST: flatbuffers::VOffsetT = 18;
  pub const VT_ELBOW: flatbuffers::VOffsetT = 20;

  pub const fn get_fully_qualified_name() -> &'static str {
    "StardustXR.Hand"
  }

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Hand { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args HandArgs<'args>
  ) -> flatbuffers::WIPOffset<Hand<'bldr>> {
    let mut builder = HandBuilder::new(_fbb);
    if let Some(x) = args.elbow { builder.add_elbow(x); }
    if let Some(x) = args.wrist { builder.add_wrist(x); }
    if let Some(x) = args.palm { builder.add_palm(x); }
    if let Some(x) = args.little { builder.add_little(x); }
    if let Some(x) = args.ring { builder.add_ring(x); }
    if let Some(x) = args.middle { builder.add_middle(x); }
    if let Some(x) = args.index { builder.add_index(x); }
    if let Some(x) = args.thumb { builder.add_thumb(x); }
    builder.add_right(args.right);
    builder.finish()
  }

  pub fn unpack(&self) -> HandT {
    let right = self.right();
    let thumb = {
      let x = self.thumb();
      x.unpack()
    };
    let index = {
      let x = self.index();
      x.unpack()
    };
    let middle = {
      let x = self.middle();
      x.unpack()
    };
    let ring = {
      let x = self.ring();
      x.unpack()
    };
    let little = {
      let x = self.little();
      x.unpack()
    };
    let palm = {
      let x = self.palm();
      x.unpack()
    };
    let wrist = {
      let x = self.wrist();
      x.unpack()
    };
    let elbow = self.elbow().map(|x| {
      x.unpack()
    });
    HandT {
      right,
      thumb,
      index,
      middle,
      ring,
      little,
      palm,
      wrist,
      elbow,
    }
  }

  #[inline]
  pub fn right(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(Hand::VT_RIGHT, Some(false)).unwrap()}
  }
  #[inline]
  pub fn thumb(&self) -> &'a Thumb {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<Thumb>(Hand::VT_THUMB, None).unwrap()}
  }
  #[inline]
  pub fn index(&self) -> &'a Finger {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<Finger>(Hand::VT_INDEX, None).unwrap()}
  }
  #[inline]
  pub fn middle(&self) -> &'a Finger {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<Finger>(Hand::VT_MIDDLE, None).unwrap()}
  }
  #[inline]
  pub fn ring(&self) -> &'a Finger {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<Finger>(Hand::VT_RING, None).unwrap()}
  }
  #[inline]
  pub fn little(&self) -> &'a Finger {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<Finger>(Hand::VT_LITTLE, None).unwrap()}
  }
  #[inline]
  pub fn palm(&self) -> &'a Joint {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<Joint>(Hand::VT_PALM, None).unwrap()}
  }
  #[inline]
  pub fn wrist(&self) -> &'a Joint {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<Joint>(Hand::VT_WRIST, None).unwrap()}
  }
  #[inline]
  pub fn elbow(&self) -> Option<&'a Joint> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<Joint>(Hand::VT_ELBOW, None)}
  }
}

impl flatbuffers::Verifiable for Hand<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<bool>("right", Self::VT_RIGHT, false)?
     .visit_field::<Thumb>("thumb", Self::VT_THUMB, true)?
     .visit_field::<Finger>("index", Self::VT_INDEX, true)?
     .visit_field::<Finger>("middle", Self::VT_MIDDLE, true)?
     .visit_field::<Finger>("ring", Self::VT_RING, true)?
     .visit_field::<Finger>("little", Self::VT_LITTLE, true)?
     .visit_field::<Joint>("palm", Self::VT_PALM, true)?
     .visit_field::<Joint>("wrist", Self::VT_WRIST, true)?
     .visit_field::<Joint>("elbow", Self::VT_ELBOW, false)?
     .finish();
    Ok(())
  }
}
pub struct HandArgs<'a> {
    pub right: bool,
    pub thumb: Option<&'a Thumb>,
    pub index: Option<&'a Finger>,
    pub middle: Option<&'a Finger>,
    pub ring: Option<&'a Finger>,
    pub little: Option<&'a Finger>,
    pub palm: Option<&'a Joint>,
    pub wrist: Option<&'a Joint>,
    pub elbow: Option<&'a Joint>,
}
impl<'a> Default for HandArgs<'a> {
  #[inline]
  fn default() -> Self {
    HandArgs {
      right: false,
      thumb: None, // required field
      index: None, // required field
      middle: None, // required field
      ring: None, // required field
      little: None, // required field
      palm: None, // required field
      wrist: None, // required field
      elbow: None,
    }
  }
}

pub struct HandBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> HandBuilder<'a, 'b> {
  #[inline]
  pub fn add_right(&mut self, right: bool) {
    self.fbb_.push_slot::<bool>(Hand::VT_RIGHT, right, false);
  }
  #[inline]
  pub fn add_thumb(&mut self, thumb: &Thumb) {
    self.fbb_.push_slot_always::<&Thumb>(Hand::VT_THUMB, thumb);
  }
  #[inline]
  pub fn add_index(&mut self, index: &Finger) {
    self.fbb_.push_slot_always::<&Finger>(Hand::VT_INDEX, index);
  }
  #[inline]
  pub fn add_middle(&mut self, middle: &Finger) {
    self.fbb_.push_slot_always::<&Finger>(Hand::VT_MIDDLE, middle);
  }
  #[inline]
  pub fn add_ring(&mut self, ring: &Finger) {
    self.fbb_.push_slot_always::<&Finger>(Hand::VT_RING, ring);
  }
  #[inline]
  pub fn add_little(&mut self, little: &Finger) {
    self.fbb_.push_slot_always::<&Finger>(Hand::VT_LITTLE, little);
  }
  #[inline]
  pub fn add_palm(&mut self, palm: &Joint) {
    self.fbb_.push_slot_always::<&Joint>(Hand::VT_PALM, palm);
  }
  #[inline]
  pub fn add_wrist(&mut self, wrist: &Joint) {
    self.fbb_.push_slot_always::<&Joint>(Hand::VT_WRIST, wrist);
  }
  #[inline]
  pub fn add_elbow(&mut self, elbow: &Joint) {
    self.fbb_.push_slot_always::<&Joint>(Hand::VT_ELBOW, elbow);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> HandBuilder<'a, 'b> {
    let start = _fbb.start_table();
    HandBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Hand<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, Hand::VT_THUMB,"thumb");
    self.fbb_.required(o, Hand::VT_INDEX,"index");
    self.fbb_.required(o, Hand::VT_MIDDLE,"middle");
    self.fbb_.required(o, Hand::VT_RING,"ring");
    self.fbb_.required(o, Hand::VT_LITTLE,"little");
    self.fbb_.required(o, Hand::VT_PALM,"palm");
    self.fbb_.required(o, Hand::VT_WRIST,"wrist");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Hand<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Hand");
      ds.field("right", &self.right());
      ds.field("thumb", &self.thumb());
      ds.field("index", &self.index());
      ds.field("middle", &self.middle());
      ds.field("ring", &self.ring());
      ds.field("little", &self.little());
      ds.field("palm", &self.palm());
      ds.field("wrist", &self.wrist());
      ds.field("elbow", &self.elbow());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct HandT {
  pub right: bool,
  pub thumb: ThumbT,
  pub index: FingerT,
  pub middle: FingerT,
  pub ring: FingerT,
  pub little: FingerT,
  pub palm: JointT,
  pub wrist: JointT,
  pub elbow: Option<JointT>,
}
impl Default for HandT {
  fn default() -> Self {
    Self {
      right: false,
      thumb: Default::default(),
      index: Default::default(),
      middle: Default::default(),
      ring: Default::default(),
      little: Default::default(),
      palm: Default::default(),
      wrist: Default::default(),
      elbow: None,
    }
  }
}
impl HandT {
  pub fn pack<'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b>
  ) -> flatbuffers::WIPOffset<Hand<'b>> {
    let right = self.right;
    let thumb_tmp = Some(self.thumb.pack());
    let thumb = thumb_tmp.as_ref();
    let index_tmp = Some(self.index.pack());
    let index = index_tmp.as_ref();
    let middle_tmp = Some(self.middle.pack());
    let middle = middle_tmp.as_ref();
    let ring_tmp = Some(self.ring.pack());
    let ring = ring_tmp.as_ref();
    let little_tmp = Some(self.little.pack());
    let little = little_tmp.as_ref();
    let palm_tmp = Some(self.palm.pack());
    let palm = palm_tmp.as_ref();
    let wrist_tmp = Some(self.wrist.pack());
    let wrist = wrist_tmp.as_ref();
    let elbow_tmp = self.elbow.as_ref().map(|x| x.pack());
    let elbow = elbow_tmp.as_ref();
    Hand::create(_fbb, &HandArgs{
      right,
      thumb,
      index,
      middle,
      ring,
      little,
      palm,
      wrist,
      elbow,
    })
  }
}
}  // pub mod StardustXR

